# Plat Expression SDK (plat-expr-sdk)

## Install

### Add private registry

```
npm set registry http://npm-registry.channelprecision.com
```

### Install package

```
npm install plat-expr-sdk
```

## Expression Syntax

### Datasource Query Expression

#### Main expressions

- Aggregation without condition

```
COUNT () as $string
COUNT (dv_id) as $string
COUNT (bin_exp) as $string
COUNT (bin_exp, dv_id) as $string

SUM ($column_name) as $string
SUM ($column_name, dv_id) as $string
SUM ($column_name, bin_exp) as $string
SUM ($column_name, bin_exp, dv_id) as $string

AVG ($column_name) as $string
AVG ($column_name, dv_id) as $string
AVG ($column_name, bin_exp) as $string
AVG ($column_name, bin_exp, dv_id) as $string

MIN ($column_name) as $string
MIN ($column_name, dv_id) as $string
MIN ($column_name, bin_exp) as $string
MIN ($column_name, bin_exp, dv_id) as $string

MAX ($column_name) as $string
MAX ($column_name, dv_id) as $string
MAX ($column_name, bin_exp) as $string
MAX ($column_name, bin_exp, dv_id) as $string
```

- Aggregation with condition

```
COUNTIF () as $string
COUNTIF (dv_id) as $string
COUNTIF ($condition) as $string
COUNTIF ($condition, dv_id) as $string
COUNTIF ($bin_exp) as $string
COUNTIF ($bin_exp, dv_id) as $string
COUNTIF ($condition, $bin_exp) as $string
COUNTIF ($condition, $bin_exp, dv_id) as $string

SUMIF ($column_name) as $string
SUMIF ($column_name, dv_id) as $string
SUMIF ($column_name, $condition) as $string
SUMIF ($column_name, $condition, dv_id) as $string
SUMIF ($column_name, $bin_exp) as $string
SUMIF ($column_name, $bin_exp, dv_id) as $string
SUMIF ($column_name, $condition, $bin_exp) as $string
SUMIF ($column_name, $condition, $bin_exp, dv_id) as $string

AVGIF ($column_name) as $string
AVGIF ($column_name, dv_id) as $string
AVGIF ($column_name, $condition) as $string
AVGIF ($column_name, $condition, dv_id) as $string
AVGIF ($column_name, $bin_exp) as $string
AVGIF ($column_name, $bin_exp, dv_id) as $string
AVGIF ($column_name, $condition, $bin_exp) as $string
AVGIF ($column_name, $condition, $bin_exp, dv_id) as $string

MINIF ($column_name) as $string
MINIF ($column_name, dv_id) as $string
MINIF ($column_name, $condition) as $string
MINIF ($column_name, $condition, dv_id) as $string
MINIF ($column_name, $bin_exp) as $string
MINIF ($column_name, $bin_exp, dv_id) as $string
MINIF ($column_name, $condition, $bin_exp) as $string
MINIF ($column_name, $condition, $bin_exp, dv_id) as $string

MAXIF ($column_name) as $string
MAXIF ($column_name, dv_id) as $string
MAXIF ($column_name, $condition) as $string
MAXIF ($column_name, $condition, dv_id) as $string
MAXIF ($column_name, $bin_exp) as $string
MAXIF ($column_name, $bin_exp, dv_id) as $string
MAXIF ($column_name, $condition, $bin_exp) as $string
MAXIF ($column_name, $condition, $bin_exp, dv_id) as $string
```

- Basic calculation

```
$aggregation_1 + $aggregation_2
$aggregation_1 - $aggregation_2
$aggregation_1 * $aggregation_2
$aggregation_1 / $aggregation_2
$aggregation_1 ^ $aggregation_2
```

- Combined expressions calculation

```
$aggregation_1 + $aggregation_2 * $aggregation_3
$aggregation_1 - $aggregation_2 ^ $aggregation_3
($aggregation_1 - $aggregation_2) / $aggregation_3
```

#### Sub expressions

- Bin expression

```
LAST_BIN_OF($column_name, number_of_bins)
LAST_BIN_OF($column_name, width, unit)
FIRST_BIN_OF($column_name, number_of_bins)
FIRST_BIN_OF($column_name, width, unit)
```

- Condition expression

```
$condition "AND" | "&&" | "&" $condition
$condition "OR" | "||" $condition

$column_name "==" | "=" | "eq" | "$eq" <$string | $number>
$column_name "!=" | "ne" | "$ne" $string | $number
$column_name ">" | "gt" | "$gt" $string | $number
$column_name ">=" | "gt" | "$gt" $string | $number
$column_name "<" | "lt" | "$lt" $string | $number
$column_name "<=" | "lte" | "$lte" $string | $number
$column_name empty
$column_name not_empty
$column_name null
$column_name not_null
$column_name contains $string
$column_name not_contains $string
$column_name starts_with $string
$column_name not_start_with $string
$column_name ends_with $string
$column_name not_end_with $string
$column_name in_range $string | $number
$column_name in $string | $number
```

- Column expression: must start with "@"

```
@column_name
@'column name with space'
@"column name with double quotes"
```

- Static expression (from plat-sdk):
```
TODAY()
YESTERDAY()
DATE_THIS($string)
DATE_LAST($number, $string)
FORMAT($string,$string)
```
#### Base expressions

- String expression (supporting special character: `_` , `-` , `:` , `/`)

```
something // no quotes -> should not contains space

// enclosed with quotes -> can contains space
'something here with space'
"something here with space"
`something here with space`
'123abc' // start with a number -> should be enclosed with quotes 
```

- Number expression

```
// integer
1234
-1234

// float
1234.56
-1234.56
```

- Boolean expression: `TRUE`, `FALSE`, `true`, `false`
- Date expression: `DATE('2020-05-15')`, `Date('2020/05/15')`
- Null value expression: `NULL`, `null`
### DsCalculatedColumn Expression

#### Main expressions

- Switch/case expression:

```
CASE
WHEN $condition1 THEN $result1
WHEN $condition2 THEN $result2
ELSE result3
```

- Calculation expression:

```
@Column1 + ( @Column2 - @Column3 ) * @Column4 / @Column5 ^ 6
```

#### Sub expressions

- Condition expression: same as Datasource Query Expression
- Switch/case \$result: Can be a string / number / Calculation expression

## Usage

### Datasource Query Expression

Define your query excution by extending `DsQueryExecAbstract`

```typescript
// ds-query-exec.ts
import { DsQueryExecAbstract, DsQueryParseResultType, DsQueryExecResult } from 'plat-expr-sdk';

export class DsQueryExecService extends DsQueryExecAbstract {
  /**
   * DS query process excution
   * @param dvOrDsId Datasource ID or Dataview ID to query
   * @param query ds-api standard query object https://mayoretailinternetservices.atlassian.net/wiki/spaces/DSP/pages/3932256/Queries
   * @param column expected response column info
   */
  async exec(
    dvOrDsId: string,
    query: any,
    column: { type: DsQueryParseResultType; alias: string }
  ): Promise<DsQueryExecResult> {
    return {
      cols: [{ name: 'name', type: 'number' }],
      rows: [[1000]],
    };
  }
}
```

Provide `DsQueryExecAbstract` to `DsQueryExpr`

```typescript
import { DsQueryExpr } from 'plat-expr-sdk';
import { DsQueryExecService } from './ds-query-exec';

const dsQueryExec = new DsQueryExecService();
const dsQueryExpr = new DsQueryExpr();
dsQueryExpr.eval('dvOrDsId to be query', 'Put expression here').then((result) => {
  // Query result of the expression
});
```

### DsCalculatedColumn expression

```typescript
import { DsCalculatedColumnExpr } from 'plat-expr-sdk';

const expression =
  'CASE WHEN @"ShipRegion" empty THEN empty WHEN @"ShipRegion" contains EU THEN "contain EU" WHEN @ShipRegion not_start_with NA THEN "Not start with NA" ELSE "Others" END';

const result = DsCalculatedColumnExpr.parse(expression);
```

Result:

```
{
    "$switch": {
        "branches": [
            {
                "case": {
                    "$eq": [
                        "$ShipRegion",
                        ""
                    ]
                },
                "then": "empty"
            },
            {
                "case": {
                    "$regexMatch": {
                        "input": "$ShipRegion",
                        "regex": "EU",
                        "options": "i"
                    }
                },
                "then": "contain EU"
            },
            {
                "case": {
                    "$not": {
                        "$regexMatch": {
                            "input": "$ShipRegion",
                            "regex": "^NA",
                            "options": "i"
                        }
                    }
                },
                "then": "Not start with NA"
            }
        ],
        "default": "Others"
    }
}
```
