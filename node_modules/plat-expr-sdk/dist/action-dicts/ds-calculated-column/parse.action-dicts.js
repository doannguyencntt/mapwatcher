"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DsCalculatedColumnParseActionsDicts = void 0;
exports.DsCalculatedColumnParseActionsDicts = {
    //--------------------------Conditions expressions------------------------
    SwitchExp: function (_CASE, caseExps, defaultExp, _END) {
        return {
            $switch: {
                branches: caseExps.parse(),
                default: defaultExp.parse(),
            },
        };
    },
    SwitchCaseExp: function (_WHEN, condition, _THEN, result) {
        return { case: condition.parse(), then: result.parse() };
    },
    SwitchDefaultExp: function (_ELSE, result) {
        return result.parse();
    },
    FilterLogicExp_and: function (a, _syntax, b) {
        var _a;
        var parsedA = a.parse();
        var parsedB = b.parse();
        if (parsedA.$and && parsedB.$and) {
            (_a = parsedA.$and).push.apply(_a, parsedB.$and);
            return parsedA;
        }
        if (parsedA.$and) {
            parsedA.$and.push(parsedB);
            return parsedA;
        }
        if (parsedB.$and) {
            return { $and: __spreadArrays([parsedA], parsedB.$and) };
        }
        return { $and: [parsedA, parsedB] };
    },
    FilterLogicExp_or: function (a, _syntax, b) {
        var _a;
        var parsedA = a.parse();
        var parsedB = b.parse();
        if (parsedA.$or && parsedB.$or) {
            (_a = parsedA.$or).push.apply(_a, parsedB.$or);
            return parsedA;
        }
        if (parsedA.$or) {
            parsedA.$or.push(parsedB);
            return parsedA;
        }
        if (parsedB.$or) {
            return { $or: __spreadArrays([parsedA], parsedB.$or) };
        }
        return { $or: [parsedA, parsedB] };
    },
    FilterOpExp_eq: function (a, _syntax, b) {
        return { $eq: [a.parse(), b.parse()] };
    },
    FilterOpExp_ne: function (a, _syntax, b) {
        return { $ne: [a.parse(), b.parse()] };
    },
    FilterOpExp_gt: function (a, _syntax, b) {
        return { $gt: [a.parse(), b.parse()] };
    },
    FilterOpExp_gte: function (a, _syntax, b) {
        return { $gte: [a.parse(), b.parse()] };
    },
    FilterOpExp_lt: function (a, _syntax, b) {
        return { $lt: [a.parse(), b.parse()] };
    },
    FilterOpExp_lte: function (a, _syntax, b) {
        return { $lte: [a.parse(), b.parse()] };
    },
    FilterOpExp_empty: function (a, _syntax) {
        return { $eq: [a.parse(), ''] };
    },
    FilterOpExp_not_empty: function (a, _syntax) {
        return { $ne: [a.parse(), ''] };
    },
    FilterOpExp_null: function (a, _syntax) {
        return { $eq: [{ $type: a.parse() }, 'null'] };
    },
    FilterOpExp_not_null: function (a, _syntax) {
        return { $ne: [{ $type: a.parse() }, 'null'] };
    },
    FilterOpExp_contains: function (a, _syntax, b) {
        return { $regexMatch: { input: a.parse(), regex: b.parse(), options: 'i' } };
    },
    FilterOpExp_not_contains: function (a, _syntax, b) {
        return { $not: { $regexMatch: { input: a.parse(), regex: b.parse(), options: 'i' } } };
    },
    FilterOpExp_starts_with: function (a, _syntax, b) {
        return { $regexMatch: { input: a.parse(), regex: "^" + b.parse(), options: 'i' } };
    },
    FilterOpExp_not_start_with: function (a, _syntax, b) {
        return { $not: { $regexMatch: { input: a.parse(), regex: "^" + b.parse(), options: 'i' } } };
    },
    FilterOpExp_ends_with: function (a, _syntax, b) {
        return { $regexMatch: { input: a.parse(), regex: b.parse() + "$", options: 'i' } };
    },
    FilterOpExp_not_end_with: function (a, _syntax, b) {
        return { $not: { $regexMatch: { input: a.parse(), regex: b.parse() + "$", options: 'i' } } };
    },
    //--------------------------Calculation expressions------------------------
    AddExp_plus: function (a, _plus, b) {
        var _a;
        var parsedA = a.parse();
        var parsedB = b.parse();
        if (parsedA.$add && parsedB.$add) {
            (_a = parsedA.$add).push.apply(_a, parsedB.$add);
            return parsedA;
        }
        if (parsedA.$add) {
            parsedA.$add.push(parsedB);
            return parsedA;
        }
        if (parsedB.$add) {
            return { $add: __spreadArrays([parsedA], parsedB.$add) };
        }
        return { $add: [parsedA, parsedB] };
    },
    AddExp_minus: function (a, _minus, b) {
        return { $subtract: [a.parse(), b.parse()] };
    },
    MulExp_times: function (a, _times, b) {
        var _a;
        var parsedA = a.parse();
        var parsedB = b.parse();
        if (parsedA.$multiply && parsedB.$multiply) {
            (_a = parsedA.$multiply).push.apply(_a, parsedB.$multiply);
            return parsedA;
        }
        if (parsedA.$multiply) {
            parsedA.$multiply.push(parsedB);
            return parsedA;
        }
        if (parsedB.$multiply) {
            return { $multiply: __spreadArrays([parsedA], parsedB.$multiply) };
        }
        return { $multiply: [parsedA, parsedB] };
    },
    MulExp_divide: function (a, _divide, b) {
        return { $divide: [a.parse(), b.parse()] };
    },
    PowExp_power: function (a, _power, b) {
        return { $pow: [a.parse(), b.parse()] };
    },
    PriExp_paren: function (_LB, exp, _RB) {
        return exp.parse();
    },
    //--------------------------plat-sdk Static expressions------------------------
    StaticExp: function (_) {
        return _.sourceString;
    },
    //--------------------------Extends base expressions------------------------
    Column: function (_at, column) {
        return "$" + column.parse();
    },
    number: function (_n) {
        return Number(this.sourceString);
    },
};
