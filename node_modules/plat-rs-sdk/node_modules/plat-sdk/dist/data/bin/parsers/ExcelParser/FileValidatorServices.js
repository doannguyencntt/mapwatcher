"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileValidatorServices = void 0;
var errors_1 = require("./errorException/errors");
var lodash_1 = __importDefault(require("lodash"));
var praseStringToCommonDataType_1 = require("./utils/praseStringToCommonDataType");
var parseListObjectWithDataType_1 = require("./utils/parseListObjectWithDataType");
var fs = require('fs');
var CSVFileValidator = require('csv-file-validator');
var ExcelJS = require('exceljs');
var mime = require('mime-types');
var csv = ['(text\/csv)', '(application\/csv)'];
var excel = ['(application\/vnd.ms-excel)', '(application\/vnd.openxmlformats-officedocument.spreadsheetml.sheet)'];
var allowedTypesRegex = new RegExp(csv.concat(excel).join("|"), "i");
var FileValidatorServices = /** @class */ (function () {
    function FileValidatorServices() {
    }
    FileValidatorServices.validateExtension = function (file) {
        try {
            var contentType = void 0;
            if (file.hapi) {
                // from hapi request
                contentType = mime.lookup(file.hapi.filename);
            }
            else {
                /**
                 * from another ( ftp, http, google sheet )
                 */
                contentType = mime.lookup(file);
            }
            return {
                boolean: allowedTypesRegex.test(contentType),
                contentType: contentType
            };
        }
        catch (error) {
            console.log('[FileValidatorServices][validateExtension]', error);
            throw new errors_1.InvalidExtension('invalid extension!');
        }
    };
    FileValidatorServices.validateFileCsv = function (cols, file) {
        return __awaiter(this, void 0, void 0, function () {
            var result, configHeaders, _loop_1, _i, cols_1, item, config, data, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 6, , 7]);
                        configHeaders = [];
                        _loop_1 = function (item) {
                            configHeaders.push({
                                name: item.name,
                                inputName: item.name,
                                headerError: function (headerName) {
                                    return "Header name " + headerName + " is not correct or missing";
                                },
                                validate: function (value) {
                                    /**
                                     * validate by parsing data
                                     */
                                    var type = item.type;
                                    value = praseStringToCommonDataType_1.parseStringToCommonDataType(value, type);
                                    if (value && value instanceof errors_1.ErrorParsingDataException) {
                                        return false;
                                    }
                                },
                                validateError: function (headerName, rowNumber, columnNumber) {
                                    return "Invalid data type at row: " + rowNumber + ", column name: " + headerName;
                                }
                            });
                        };
                        for (_i = 0, cols_1 = cols; _i < cols_1.length; _i++) {
                            item = cols_1[_i];
                            _loop_1(item);
                        }
                        config = {
                            headers: configHeaders
                        };
                        if (!file.hapi) return [3 /*break*/, 2];
                        return [4 /*yield*/, CSVFileValidator(file, config)];
                    case 1:
                        /***
                         * from hapi's request
                         */
                        result = _a.sent();
                        return [3 /*break*/, 5];
                    case 2: return [4 /*yield*/, fs.createReadStream(file)];
                    case 3:
                        data = _a.sent();
                        return [4 /*yield*/, CSVFileValidator(data, config)];
                    case 4:
                        result = _a.sent();
                        _a.label = 5;
                    case 5:
                        result.data.shift(); // remove headers
                        result.data = parseListObjectWithDataType_1.parseListObjectsWithDataType(result.data, cols);
                        return [3 /*break*/, 7];
                    case 6:
                        error_1 = _a.sent();
                        console.log('[FileValidatorServices][validateFileCsv]', error_1);
                        if (error_1.error) {
                            throw error_1.error;
                        }
                        throw error_1;
                    case 7:
                        if (lodash_1.default.isEmpty(result.data) && lodash_1.default.isEmpty(result.inValidMessages)) {
                            result.inValidMessages.push('The number of columns in file are less than in data source schema!');
                        }
                        result.inValidMessages = result.inValidMessages.slice(0, 100);
                        return [2 /*return*/, result];
                }
            });
        });
    };
    FileValidatorServices.validateFileExcel = function (cols, file) {
        return __awaiter(this, void 0, void 0, function () {
            var workbook, buf, workSheetName, worksheet, data_1, inValidMessages_1, headersFromDataSourceSchema_1, i, headers_1, error_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 5, , 6]);
                        workbook = new ExcelJS.Workbook();
                        buf = file._data;
                        if (!file._data) return [3 /*break*/, 2];
                        /**
                         * read from hapi's request
                         * buffer
                         */
                        return [4 /*yield*/, workbook.xlsx.load(buf)];
                    case 1:
                        /**
                         * read from hapi's request
                         * buffer
                         */
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 2: 
                    /**
                     * read from local file path
                     */
                    return [4 /*yield*/, workbook.xlsx.readFile(file)];
                    case 3:
                        /**
                         * read from local file path
                         */
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        workSheetName = workbook._worksheets[1].name;
                        worksheet = workbook.getWorksheet(workSheetName);
                        data_1 = [];
                        inValidMessages_1 = [];
                        headersFromDataSourceSchema_1 = [];
                        for (i = 0; i < cols.length; i++) {
                            headersFromDataSourceSchema_1.push(cols[i].name);
                        }
                        headers_1 = [];
                        worksheet.eachRow({ includeEmpty: true }, function (row, rowNumber) {
                            if (rowNumber === 1) {
                                // validate headers
                                // compare to headers are stored in schema db
                                headers_1 = row.values;
                                /**
                                 * first value is undefined
                                 * remove first it
                                 */
                                headers_1.shift();
                                for (var i = 0; i < headers_1.length; i++) {
                                    /**
                                     * headers must be type of string
                                     * if type of number -> parse to string
                                     */
                                    if (typeof headers_1[i] !== typeof 'string') {
                                        headers_1[i] = headers_1[i].toString();
                                    }
                                }
                                for (var i = 0; i < headersFromDataSourceSchema_1.length; i++) {
                                    if (!headers_1.includes(headersFromDataSourceSchema_1[i])) {
                                        inValidMessages_1.push("Header name " + headersFromDataSourceSchema_1[i] + " is not correct or missing");
                                    }
                                }
                            }
                            else {
                                /**
                                 * file could include empty rows
                                 * ignore them
                                 */
                                if (row.values.length !== 0) {
                                    var parsedRow_1 = {};
                                    // { headerName: value } -> data[]
                                    /**
                                     * first column is undefined
                                     * remove it
                                     */
                                    row = row.values;
                                    row.shift();
                                    /**
                                     * headers.length could be larger than row.length
                                     * because exceljs ignores null values in a row
                                     */
                                    /**
                                     * step 1: parse available values
                                     */
                                    for (var i = 0; i < row.length; i++) {
                                        var key = headers_1[i];
                                        /**
                                         * just parse columns and values that are adapted to data source schema
                                         */
                                        if (headersFromDataSourceSchema_1.includes(key)) {
                                            var type = FileValidatorServices.getType(cols, key).type;
                                            var tempValue = row[i];
                                            /**
                                             * case value is a formula in excel file
                                             */
                                            if (tempValue && tempValue.hasOwnProperty('formula')) {
                                                /**
                                                 * formula has prop result -> result
                                                 *         doesnt have     -> default:
                                                 *                              type: number -> 0
                                                 *                              type: (string, date, ...) -> null
                                                 */
                                                tempValue = tempValue.hasOwnProperty('result') ? tempValue.result : lodash_1.default.isEqual(type, 'number') ? 0 : null;
                                            }
                                            /**
                                             * case undefined | null value
                                             * -> skip and assign null later to avoid parsing data below
                                             */
                                            if (!tempValue && typeof tempValue !== "boolean" && typeof tempValue !== "number") {
                                                continue;
                                            }
                                            /**
                                             * case available value
                                             * parse to appropriate data type
                                             */
                                            var value = praseStringToCommonDataType_1.parseStringToCommonDataType(tempValue, type);
                                            /**
                                             * validate type of each value in a row
                                             * parse value to appropriate data type schema
                                             * value is exception variable -> invalid data type
                                             */
                                            if (value && value instanceof errors_1.ErrorParsingDataException) {
                                                inValidMessages_1.push("Invalid data type at row: " + rowNumber + ", column name: " + key);
                                            }
                                            parsedRow_1[key] = value;
                                        }
                                    }
                                    /**
                                     * step 2: assign null value based on schema
                                     */
                                    headersFromDataSourceSchema_1.forEach(function (header) {
                                        var _a;
                                        if (!parsedRow_1.hasOwnProperty(header)) {
                                            Object.assign(parsedRow_1, (_a = {}, _a[header] = null, _a));
                                        }
                                    });
                                    data_1.push(parsedRow_1);
                                }
                            }
                        });
                        inValidMessages_1 = inValidMessages_1.slice(0, 100);
                        return [2 /*return*/, {
                                data: data_1,
                                inValidMessages: inValidMessages_1
                            }];
                    case 5:
                        error_2 = _a.sent();
                        console.log('[FileValidatorServices][validateFileExcel]', error_2);
                        throw error_2;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    FileValidatorServices.getType = function (cols, name) {
        for (var i = 0; i < cols.length; i++) {
            if (cols[i].name === name) {
                return cols[i];
            }
        }
        /**
         * default
         */
        return cols[0];
    };
    /**
     * validate and get data from file based on schema
     * @param file
     * @param cols
     */
    FileValidatorServices.prototype.validateAndGetData = function (file, cols) {
        return __awaiter(this, void 0, void 0, function () {
            var validateExtension, fileData, extension, error_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        validateExtension = FileValidatorServices.validateExtension(file);
                        if (!validateExtension.boolean) {
                            throw new errors_1.InvalidExtension('invalid extension!');
                        }
                        extension = '(' + validateExtension.contentType + ')';
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        if (!csv.includes(extension)) return [3 /*break*/, 3];
                        return [4 /*yield*/, FileValidatorServices.validateFileCsv(cols, file)];
                    case 2:
                        // csv
                        fileData = _a.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, FileValidatorServices.validateFileExcel(cols, file)];
                    case 4:
                        // excel
                        fileData = _a.sent();
                        _a.label = 5;
                    case 5:
                        console.log('[FileValidatorServices][validateAndGetData] 1st result', JSON.stringify(fileData.data[0]));
                        return [3 /*break*/, 7];
                    case 6:
                        error_3 = _a.sent();
                        console.log('[FileValidatorServices][validateAndGetData]', error_3);
                        throw error_3;
                    case 7:
                        if (!lodash_1.default.isEmpty(fileData.inValidMessages)) {
                            throw new errors_1.InvalidFileImport(fileData.inValidMessages);
                        }
                        return [2 /*return*/, fileData];
                }
            });
        });
    };
    /**
     * validate json data based on schema
     * @param data
     * @param cols
     */
    FileValidatorServices.prototype.validateJsonData = function (data, cols) {
        var inValidMessages = [];
        var parsedData = [];
        try {
            data.forEach(function (row, rowNumber) {
                var _a;
                var parsedRow = {};
                for (var _i = 0, cols_2 = cols; _i < cols_2.length; _i++) {
                    var col = cols_2[_i];
                    /**
                     * validate required schema columns
                     */
                    if (!row.hasOwnProperty(col.name)) {
                        inValidMessages.push("Header name " + col.name + " is not correct or missing");
                        continue;
                    }
                    /**
                     * case undefined | null value
                     * -> skip and assign null later to avoid parsing data below
                     */
                    if (!row[col.name] && typeof row[col.name] !== "boolean" && typeof row[col.name] !== "number") {
                        continue;
                    }
                    /**
                     * case available value
                     * parse to appropriate data type
                     */
                    var value = praseStringToCommonDataType_1.parseStringToCommonDataType(row[col.name], col.type);
                    /**
                     * validate type of each value in a row
                     * parse value to appropriate data type schema
                     * value is exception variable -> invalid data type
                     */
                    if (value && value instanceof errors_1.ErrorParsingDataException) {
                        inValidMessages.push("Invalid data type at row: " + (rowNumber + 1) + ", column name: " + col.name);
                    }
                    else {
                        Object.assign(parsedRow, (_a = {}, _a[col.name] = value, _a));
                    }
                }
                parsedData.push(parsedRow);
            });
            inValidMessages = inValidMessages.slice(0, 100);
        }
        catch (e) {
            console.log('[FileValidatorServices][validateJsonData]', e);
            throw e;
        }
        console.log(parsedData);
        if (!lodash_1.default.isEmpty(inValidMessages)) {
            throw new errors_1.InvalidFileImport(inValidMessages);
        }
        return {
            data: parsedData,
            inValidMessages: inValidMessages
        };
    };
    return FileValidatorServices;
}());
exports.FileValidatorServices = FileValidatorServices;
