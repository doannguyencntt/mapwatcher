"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumericBin = void 0;
var listBaseSuggestWidth = [1, 2, 5, 10];
var NumericBin = /** @class */ (function () {
    function NumericBin() {
    }
    /**
     * This func will return the array of bin from (with, unit)
     *
     * @param min
     * @param max
     * @param width
     * @param nice
     */
    NumericBin.prototype.makeUniformBins = function (min, max, width, nice) {
        if (typeof min !== 'number' || typeof max !== 'number' || typeof width !== 'number') {
            throw "invalid input min " + min + " " + typeof min + ", max: " + max + " " + typeof max + ", width: " + width + " " + typeof width;
        }
        if (typeof nice !== 'boolean') {
            throw "invalid nice input " + nice;
        }
        var binResult = [];
        var toFixed = 0;
        if (max < min) {
            throw 'max number must be greater or equal min number';
        }
        if (width < 0) {
            throw "invalid width " + width;
        }
        if (!Number.isInteger(width)) {
            toFixed = 1;
        }
        var minNumber = min;
        if (nice) {
            var diff = (min % width);
            if ((min - diff) < 0) {
                minNumber = min + diff;
            }
            else {
                minNumber = min - diff;
            }
        }
        var maxNumber = Number((minNumber + width).toFixed(toFixed));
        while (1) {
            binResult.push({
                min: minNumber,
                minOp: 'gte',
                max: maxNumber,
                maxOp: "lt",
                width: width,
                label: minNumber + " - " + maxNumber
            });
            if (maxNumber >= max) {
                binResult[binResult.length - 1].maxOp = 'lte';
                break;
            }
            else {
                minNumber = maxNumber;
                maxNumber = Number((minNumber + width).toFixed(toFixed));
            }
        }
        return binResult;
    };
    /**
     * This function will return an array of bin which is closest with your expected
     *
     * @param min
     * @param max
     * @param expected
     * @param nice
     */
    NumericBin.prototype.makeAutoBins = function (min, max, expected, nice) {
        if (typeof min !== 'number' || typeof max !== 'number' || typeof expected !== 'number') {
            throw "invalid input min " + min + " " + typeof min + ", max: " + max + " " + typeof max + ", expected: " + expected + "  " + typeof expected;
        }
        if (typeof nice !== 'boolean') {
            throw "invalid input nice " + nice + " " + typeof nice;
        }
        if (max < min) {
            throw 'max number must be greater or equal min number';
        }
        if (expected < 1 || !Number.isInteger(expected)) {
            throw 'invalid expected';
        }
        if (expected > (max - min)) {
            return this.makeUniformBins(min, max, 1, nice);
        }
        var diff = Math.round((max - min) / expected);
        var widthList = this.suggestWidth(diff, expected);
        return this.makeUniformBins(min, max, widthList, nice);
    };
    NumericBin.prototype.suggestWidth = function (diff, expected) {
        var widthList = [];
        var amountBinList = [];
        var exponent = Math.floor(Math.log10(diff));
        for (var item = 0; item < listBaseSuggestWidth.length; item++) {
            widthList.push(listBaseSuggestWidth[item] * Math.pow(10, exponent));
            amountBinList.push((diff * expected) / widthList[item]);
        }
        var index = this.findClosetIndex(amountBinList, expected);
        return widthList[index];
    };
    NumericBin.prototype.findClosetIndex = function (suggest_list, goal) {
        var closest = suggest_list.reduce(function (prev, curr) {
            return (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev);
        });
        return suggest_list.indexOf(closest);
    };
    return NumericBin;
}());
exports.NumericBin = NumericBin;
