"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TemporalBin = void 0;
var constant_1 = require("./constant/constant");
var moment_timezone_1 = __importDefault(require("moment-timezone"));
var listAutoUnitAndWith = [{ unit: 'Y', width: 2 }, { unit: 'Y', width: 1 }, { unit: 'Q', width: 2 },
    { unit: 'Q', width: 1 }, { unit: 'M', width: 2 }, { unit: 'M', width: 1 }, { unit: 'W', width: 1 }, {
        unit: 'W',
        width: 1
    }, { unit: 'd', width: 1 }];
var TemporalBin = /** @class */ (function () {
    function TemporalBin(timezone) {
        this.timezone = timezone || moment_timezone_1.default.tz.guess();
    }
    /**
     * This func will return the array of bin from (width, unit)
     *
     * @param min - start date,
     * @param max - end date,
     * @param unit - 'Y','Q','M','W','d','m',
     * @param width - integer and greater then 0
     */
    TemporalBin.prototype.makeUniformBins = function (min, max, unit, width, maxBinAmount) {
        if (maxBinAmount === void 0) { maxBinAmount = 5000; }
        if (!(Object.prototype.toString.call(min) === '[object Date]')) {
            throw "invalid min date " + min;
        }
        if (!(Object.prototype.toString.call(max) === '[object Date]')) {
            throw "invalid max date " + max;
        }
        if (!(Object.values(constant_1.DateBinUnit).includes(unit))) {
            throw "invalid unit " + unit;
        }
        if (width < 1 || !Number.isInteger(width)) {
            throw "invalid width " + width;
        }
        var binResult = [];
        min = moment_timezone_1.default.tz(min, this.timezone).startOf(unit).toDate();
        max = moment_timezone_1.default.tz(max, this.timezone).endOf(unit).toDate();
        var duration;
        if (unit === constant_1.DateBinUnit.WEEK) {
            duration = moment_timezone_1.default.tz(max, this.timezone).diff(moment_timezone_1.default.tz(min, this.timezone), 'w');
        }
        else {
            duration = moment_timezone_1.default.tz(max, this.timezone).diff(moment_timezone_1.default.tz(min, this.timezone), unit);
        }
        if (duration < 0) {
            throw 'max date must be greater than min date';
        }
        var minDate = min;
        var maxDate = moment_timezone_1.default.tz(min, this.timezone).add(width, unit).toDate();
        var binAmount = duration / width;
        if (binAmount > maxBinAmount) {
            binAmount = maxBinAmount;
        }
        for (var item = 0; item <= binAmount; item++) {
            var bin = {
                min: minDate,
                minOp: 'gte',
                max: maxDate,
                maxOp: "lt",
                unit: unit,
                width: width,
                label: this.formatLabel(minDate, maxDate, unit, width)
            };
            binResult.push(bin);
            minDate = maxDate;
            maxDate = moment_timezone_1.default.tz(minDate, this.timezone).add(width, unit).toDate();
            if ((item + 1) === maxBinAmount) {
                maxDate = moment_timezone_1.default.tz(minDate, this.timezone).add(width * (duration / width - maxBinAmount + 1), unit).toDate();
            }
        }
        return binResult;
    };
    TemporalBin.prototype.formatLabel = function (min, max, unit, width) {
        var label;
        if (width > 1) {
            label = moment_timezone_1.default.tz(min, this.timezone).format(constant_1.LabelFormat[unit]) + ' - ' + moment_timezone_1.default.tz(max, this.timezone).subtract(1, unit).format(constant_1.LabelFormat[unit]);
        }
        else {
            label = moment_timezone_1.default.tz(min, this.timezone).format(constant_1.LabelFormat[unit]);
        }
        return label;
    };
    /**
     * This func will return the array of bin which have amount closest your expected
     *
     * @param min - min Date
     * @param max - max Date
     * @param expected - integer and greater then 0
     */
    TemporalBin.prototype.makeAutoBins = function (min, max, expected) {
        if (!(Object.prototype.toString.call(min) === '[object Date]')) {
            throw 'invalid min date';
        }
        if (!(Object.prototype.toString.call(max) === '[object Date]')) {
            throw 'invalid max date';
        }
        var diff = moment_timezone_1.default.tz(max, this.timezone).diff(moment_timezone_1.default.tz(min, this.timezone));
        if (diff < 0) {
            throw 'max date must be greater than min date';
        }
        if (expected < 1 || !Number.isInteger(expected)) {
            throw 'invalid expected';
        }
        var suggestList = this.getAmountBinSuggest(diff);
        var suggestIndex = this.findClosetIndex(suggestList, expected);
        return this.makeUniformBins(min, max, listAutoUnitAndWith[suggestIndex].unit, listAutoUnitAndWith[suggestIndex].width);
    };
    TemporalBin.prototype.getAmountBinSuggest = function (diff) {
        var listSuggest = [];
        var durationTime = moment_timezone_1.default.duration(diff);
        listSuggest.push(durationTime.asYears() / 2); //2 years
        listSuggest.push(durationTime.asYears()); //1 years
        listSuggest.push(durationTime.asMonths() / 6); //2 quarter
        listSuggest.push(durationTime.asMonths() / 3); //1 quarter
        listSuggest.push(durationTime.asMonths() / 2); //2 month
        listSuggest.push(durationTime.asMonths()); //1 month
        listSuggest.push(durationTime.asWeeks() / 2); //2 Weeks
        listSuggest.push(durationTime.asWeeks()); //1 weeks
        listSuggest.push(durationTime.asDays()); // 1 day
        return listSuggest;
    };
    // find index of array which is closest with the goal
    TemporalBin.prototype.findClosetIndex = function (suggest_list, goal) {
        var closest = suggest_list.reduce(function (prev, curr) {
            return (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev);
        });
        return suggest_list.indexOf(closest);
    };
    return TemporalBin;
}());
exports.TemporalBin = TemporalBin;
